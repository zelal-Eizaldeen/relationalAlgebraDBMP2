# -*- coding: utf-8 -*-
"""CS411 MP2 - Zilal Eiz AlDin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d4WYrhz70WAkJana9Os2W_YN01j0lEr6

# MP2: Implementing/Using Relational Algebra

## <font color = "red"> This document is for writing MP2 submissions.</font>
<font color = "red">

- MP2 is specified in this [instruction document](https://drive.google.com/file/d/15hRfUKXfL7o4rt97H7QJ0xeiaavCDL0L/view?usp=sharing).
- All updates, FAQ, and bug fixes, if any, will be announced in [this post](https://campuswire.com/c/G76F915C7/feed/21). Please check it frequently.
- Just write your work on this document, which you will have access till the deadline. No separate submission is necessary.
- Your work on this document will be graded here by the staff, after the deadline.
- The expected output is linked [here](https://docs.google.com/document/d/1cDTxArmDt6Jr-0iZXlRJMqfmGrat9iwh/edit?usp=sharing&ouid=112265852052044371153&rtpof=true&sd=true).
</font>

## Objectives
- Implement relational operators to compute over data.
- Compose relational expressions to query a database.
- Write different relational expressions that are equivalent.

## Submission by Week 4 (June 9, 2024)

You will receive an individual "work doc" (which is a copy of this document) for your MP2 work. Your work doc is just the Google collab notebook titled "CS411 MP2 - YourName.ipynb".

Ensure that you are working on your work doc, as any modifications to the Instructions document will not be saved.

Fill in your code in your work doc, on which you can **write/submit** your answers and **communicate with/ask** the course staff for questions.

**Please complete your work on the work doc by the submission deadline**, after which you will not have access to the document. **We will grade and provide feedback on the work doc.**

## Grading Rubric / Grading by Staff

You will receive your grades on your work doc and Coursera **in a week** after MP2 is due.

---
|Submission  |Weight|Criteria            |Comments|Grade|
|---         |---   |---                 |---     |---  |
|Submission 1|20    |Code is correct     |        |     |
|Submission 2|20    |Code is correct     |        |     |
|Submission 3|20    |Code is correct     |        |     |
|Submission 4|10    |Variant A is correct|        |     |
|            |10    |Variant B is correct|        |     |
|Submission 5|10    |Variant A is correct|        |     |
|            |10    |Variant B is correct|        |     |

## 1.1 Linking Dataset to Your Google Drive

### **Actions**

There are two methods to access the dataset.
1. "Shared with me" folder
- Go to your Google Drive.
- Under "Shared with me", find the folder "CS411-MP2-Data". Right click it.
- In the pop-up menu, first click "Organize", then click "Add shortcut" to add the folder under the root of your Google Drive.
- Then, you should see this folder appear under your "My Drive".

See this [image](https://drive.google.com/file/d/1mUx9PCoMlq9wUqyTuP6LR7Fk0_BBPMyv/view?usp=sharing).

2. Alternate instructions if you are not able to find the folder in "Shared with me":
- Download [CS411-MP2-Data](https://drive.google.com/drive/folders/1l4jNJkjCJW0yBJMAPGNHoEKsE3zD4Zg7?usp=sharing).
- Go to your Google Drive.
- Upload the folder to your Google Drive (Click "+ New", click "Folder Upload", select the folder).

See this [image](https://drive.google.com/file/d/1MPrmJRm9G-ot8VRzVBRxI-eTDMwhPVsq/view?usp=sharing)

## 1.2 Importing Libraries

### **Actions**

- Run the code below to import libraries.

----
"""

import pandas as pd

# Load the Drive helper and mount
from google.colab import drive
drive.mount('/content/drive')

"""# 2. Basics: Classes and Utilities

## 2.1 Class **Table** -- *Provided to You*

### Actions

- Run the code below to define the Table class.

----

This class defines a table (relation), which consists of a set of tuples.
   
#### **Table**

- **getAttributes()**
   - Gets a list of table attributes
   - Returns: dict keys of table attributes
- **getTuples()**
   - Gets a list of all records in the table
   - Returns: a list of records in the table
- **rename_table(new_name)**
   - Renames the table object
   - Parameters: new_name: new name to give table object
   - Returns: Nothing
- **getTableSize()**
   - Returns Size of the table object
"""

class Table (object):
    """
    Initializes Table object

    """
    def __init__(self, name):
        # initialize table name, schema and load data
        self.name = name
        self.path = ""
        self.data = None
        self.size = None


    def createTablefromCSV (self, path):
        """
        Creates a table from csv file
        """
        self.path = path
        temp_df = pd.read_csv(path)
        self.data = temp_df.to_dict('records')
        self.size = temp_df.size


    def getTableSize(self):
        """
        Returns size of table
        """
        return self.size

    def getAttributes(self):
        """
        Returns table attributes
        """
        return self.data[0].keys()

    def getTuples(self):
        """
        Returns table tuples
        """
        return self.data

    def getName(self):
        """
        Returns name of table
        """
        return self.name

    def rename_table(self, new_name):
        """
        Renames table
        """
        self.name = new_name

"""## 2.2 Class **Database** -- *Provided to You*

### **Actions**

- Run the code below to define the Database class.

----

This class defines an overall database, which consists of a set of tables.

#### **Database**  
- **createTables (paths)**
   - Creates tables from list of table paths
   - Parameters: paths: list of csv file paths = ['dataset1.csv', 'dataset2.csv']
   - Returns: Nothing
- **getTable (table_name)**
   - Gets Table Object. Note that all table names will be created from the name of their csv files
   - Parameters: table_name
   - Returns: table object
- **showTables ()**
   - Displays list of tables
   - Returns: Nothing
"""

class Database (object):
    """
    Collection of Tables
    """
    def __init__(self, db_name):
        self.db_name = db_name
        self.tables = {} #List of table objects


    def createTables(self, paths):
        """
        Creates tables from lists of paths
        :param list of csv file paths = ['dataset1.csv', 'dataset2.csv']
        """
        for path in paths:
            table_name= path.split(".")[0].split('/')[-1]
            table = Table(table_name)
            table.createTablefromCSV(path)
            self.tables[table_name]= table


    def getTable(self,table_name):
        """
        Returns Table Object
        param: table name
        returna Table Object
        """
        return self.tables[table_name]

    def showTables(self):
        """
        Prints list of tables in the database
        """
        for name in self.tables.keys():
            print(name)

"""## 2.3 Creating Database and Tables -- *Provided to You*

### **Actions**

- Run the code below to create the FridayNight database and tables. It will read the data csv files you prepared in Step 1.
"""

FridayNight = Database("FridayNight")

# Create tables in database
FridayNight.createTables(['/content/drive/My Drive/CS411-MP2-Data/Bars.csv',
                          '/content/drive/My Drive/CS411-MP2-Data/Beers.csv',
                          '/content/drive/My Drive/CS411-MP2-Data/Drinkers.csv',
                          '/content/drive/My Drive/CS411-MP2-Data/Sells.csv'])

# Show tables in database
FridayNight.showTables()


# Get Table objects
bars= FridayNight.getTable("Bars")
beers =  FridayNight.getTable("Beers")
sells =  FridayNight.getTable("Sells")
drinkers =  FridayNight.getTable("Drinkers")


# Get Table size
print("Table size for Bars: ",bars.getTableSize())


# Get Table attributes
print("Table attributes for Bars: ",bars.getAttributes())

bars.getTuples()

beers.getTuples()

"""## 2.4 Utility Functions for Relations -- *Provided to You*

### **Actions**

- Run the code below to set up the utility functions for using tables.

----

- **distinct (records)**
    - Returns distinct records for the relation
    
- **view_table(relation)**
    - Use this function to view in table format
    
- **check_schema (rel_one, rel_two)**
    - Checks if attributes of two relations are identical
"""

def view_table (relation: Table):
    """
    Returns a table format view
    :param relation Table Object
    """
    if relation is not None:
      return pd.DataFrame.from_dict(relation.getTuples())

def distinct (records: list) -> list:
    """
    Returns unique records
    :param records list of records
    """
    rel_one = pd.DataFrame.from_dict(records)
    return rel_one.drop_duplicates().to_dict('records')

def check_schema(rel_one: Table, rel_two: Table) -> bool:
    """
    Checks if attributes of two relations records are identical.
    :param rel_one Table object
    :param rel_two Table object
    :return: True if identical, else False
    """
    rel_one_local = pd.DataFrame(rel_one.getTuples())
    rel_two_local = pd.DataFrame(rel_two.getTuples())

    return set(rel_one_local.columns.values) == set(rel_two_local.columns.values)

"""## 2.5 Utility Functions for Evaluating Conditions -- *Provided to You*

### **Actions**
- Run the code below to set up the utility functions for evaluating conditions.

### Syntax of Conditions

#### 1. Atomic Condition Expression
An **atomic condition** can be expressed as follows:
- ```( colname comp_operator value )```, for a **selection condition** over one table where colname is the column name from the table, comp_operator is a comparison operator, and value is a constant, e.g., ```( name = 'SoberBar' )```.

- ```( colname_x operator colname_y )```, for a **join condition** (over two tables, where we use "_x" and "_y" to specify the column names in the *left* and the *right* tables in the join respectively, e.g., ```( beer_x = beer_y )```.

**Note:**
Our simple parser will assume you follow the following rules:
- Each expression should be enclosed in parantheses.
- **Use a space between every token-- parenthesis, operator, and operands.** **(IMPORTANT SYNTAX)**
- Constant string values do not contain space, e.g., "SoberBar" instead of "Sober Bar".

**Comparison Operators**:  ```!= , = , >= , <= , < , >```

#### 2. Complex Condition Expression

A **complex condition** can be composed by connecting atomic conditions with **logic connectives**: ```AND``` , ```OR```, e.g., ```( beer_x = beer_y ) AND ( price_y > 3.0 ) AND ( bar_y = 'SoberBar' )```.

Conditions can be nested, e.g., ```( beer_x = beer_y ) AND ( ( price_y > 3.0 ) OR ( bar_y = 'SoberBar' ) )```.
"""

operator_equivalents = {
    "AND" : "&",
    "OR"  : "|",
    "NOT" : "~",
    ""    : "|",
    "="   : "==",
    ">="  : ">=",
    "<="  : "<=",
    "!="  : "!=",
    ">"   : ">",
    "<"   : "<"
}

def eval_exp (operand_1, operator, operand_2, tuple_):

    """
    Evaluates expression on a record
    You do not need to use this function directly for the MP.
    """

    try:
        first_col = "tuple_[operand_1]" if operand_1 in tuple_ else operand_1
        second_col = "tuple_[operand_2]" if operand_2 in tuple_ else operand_2
        expression = "%s %s %s" % (first_col, operator_equivalents[operator], second_col)
        ret_val = int(eval(expression))

    except:
        # Expression incorrect
        ret_val = -1

    return ret_val


def evaluate_condition ( tuple_ , condition ):
    """
    Evaluates complete expression on a tuple/record
    You do not need to use this function directly for the MP.
    """

    operator_stack = []

    # condition= "( ( A != B ) AND ( B = C ) )"
    sequence = condition.split()

    for element in sequence :

        if element != ")":
            operator_stack.append(element)
        else:
            # pop all elements until you reach "("
            try:
                operand_2 = operator_stack.pop()
                operator = operator_stack.pop()
                operand_1 = operator_stack.pop()

                if operator_stack:
                    operator_stack.pop() # removes "("
            except:
                return -1

            ret_val = eval_exp(operand_1, operator, operand_2, tuple_)
            if ret_val == -1: return -1
            operator_stack.append(str(ret_val))

    if len(operator_stack) == 1:
        ret_val = int(operator_stack[0])
    else:
        expression = ' '.join([operator if i % 2 == 0 else operator_equivalents[operator] for i, operator in enumerate(operator_stack)])
        ret_val = eval(expression)

    if ret_val:
        return tuple_
    else:
        return None

"""# 3. Operations: Relational Operators

## 3.1 SELECT Operator -- *Provided to You*

### **Actions**
- Run the code below to define the SELECT operator.

**select (relation, condition)**
- Selects and returns records that satisfy given condition  
- Parameters:
  - relation: Table Object, the relation to be manipulated
  - condition: str, the condition for selection
- Returns:
  - Table Object, relation that satisfy condition
- **IMPORTANT** Check condition syntax to understand how to use Select
"""

def select( relation: Table, condition: str) -> Table:
    """
    Selects and returns records that satisfy given condition
        :param relation: Table Object, the table to be manipulated
        :param condition: str, the condition for selection
        :return: Table Object, relation that satisfy condition
    """

    new_relation = []

    records = relation.getTuples()

    for tuple_ in records:
        row = evaluate_condition(tuple_, condition)
        if row == -1:
            print("Condition Syntax Error")
            return None
        elif row != None:
            new_relation.append(row)

    new_relation_table = Table("Select_Relation")
    new_relation_table.data = new_relation
    return new_relation_table

R= select(bars , '( owner = "Jim" )')
view_table(R)

"""## 3.2 PROJECT Operator -- *You Provide It* **(Submission 1)**

### **Actions**
- Implement the PROJECT operator.

**project (relation, column_list)**
- Performs Projection on a given relation
- Parameters:
  - relation: Table Object, the relation to be manipulated
  - columns: list of str, list of column names to be projected
- Returns:
  - Table Object, the projected relation
- Make sure the column names in the input columns exist in the relation. **Otherwise**, print error message "*Key(s) in column does not exist in the relation!*" and return *None*.
- Project operator function should return **distinct** records.
- **DO NOT** use pandas methods to construct operator function. You can use:
  - python's list/dictionary manipulation
  - the utility functions provided above
  - other relational operators implemented in this notebook
- Columns in result/output can be displayed in any order.
"""

def project(relation: Table, columns: list) -> Table:
    """
    Performs project on a given relation
        :param relation: Table Object, the table to be manipulated
        :param columns: list of str, list of column names to be projected
        :return: Table Object, the projected relation

    """
    projected_relation = Table("Project_Relation")

    # Enter your code below
    projection_relation = []
    records = relation.getTuples()
    for col in columns:
        if col == -1:
          print("Key(s) in column does not exist in the relation!")
          return None
    for tuple_ in records:
      for key in list(tuple_):
        if key not in columns:
            del tuple_[key]

      ordered_dict_items = [(k, tuple_[k]) for k in columns]
      ordered= dict((x, y) for x, y in ordered_dict_items)


      projection_relation.append(ordered)


    projected_relation.data = projection_relation

    return projected_relation

R = project(bars, ["owner", "name"])
view_table(R)

"""## 3.3 UNION Operator -- *Provided to You*

### **Actions**
- Run the code below to define the UNION operator.

**union (relation_one, relation_two)**
- Performs Union operation on two relations
- Parameters:
  - relation_one: Table Object, one relation to be unioned
  - relation_two: Table Object, the other relation to be unioned
- Returns:
  - Table Object, the unioned relation
"""

def union ( relation_one: Table, relation_two: Table ) -> Table:
    """
    Performs Union operation on two relations
        :param relation_one: Table Object, one relation to be unioned
        :param relation_two: Table object, the other relation to be unioned
        :return: Table Object, the unioned relation

    """


    rel_one_records = relation_one.getTuples()
    rel_two_records = relation_two.getTuples()

    if check_schema(relation_one, relation_two):

        distinct_records = distinct(rel_one_records + rel_two_records)
        union_relation = Table("UnionRelation")
        union_relation.data = distinct_records
        return union_relation

    else:
        print("relation_one and relation_two does not have same schema!")
        return None
    return

R1 = select(bars, '( name = "SoberBar" )')
R2 = select(bars, '( name = "GreenBar" )')
R = union(R1, R2)
view_table(R)

"""## 3.4 Difference Operator - *Provided to You*

### **Actions**
- Run the code below to define the SET DIFFERENCE operator.

**set_difference (relation_one, relation_two)**
- Performs Set Difference on two relations
- Parameters:
  - relation_one: Table Object, the R1 relation in the set difference, or the minuend
  - relation_two: Table Object, the R2 relation in the set difference, or the subtrahend
- Returns:
  - Table Object, the resulted relation after R1 - R2
"""

def set_difference (relation_one: Table, relation_two: Table) -> Table:
    """
    Performs set difference on two relations
        :param relation_one: Table Object, the R1 relation in the set difference, or the minuend
        :param relation_two: Table Object, the R2 relation in the set difference, or the subtrahend
        :return: relation Table Object, the resulted relation after R1 - R2

    """

    records: list = []
    relation_one_records = relation_one.getTuples()
    relation_two_records = relation_two.getTuples()

    if not check_schema ( relation_one, relation_two):
        print("relation_one and relation_two does not have same schema!")
        return None

    for record in relation_one_records:
        if record not in relation_two_records:
            records.append(record)

    set_diff_table = Table ("SetDifference")
    set_diff_table.data = distinct(records)
    return set_diff_table

R1 = select (bars, '( name = "SoberBar" )')
view_table(set_difference ( bars, R1 ))

"""## 3.5 INTERSECT Operator -- *You Provide It* **(Submission 2)**

### **Actions**
- Implement the INTERSECT operator.

**intersect (relation_one, relation_two)**
- Performs intersection on two relations
- Parameters:
  - relation_one: Table Object, one relation for intersect
  - relation_two: Table Object, the other relation for intersect
- Returns:
  - Table Object, the intersection of the two relations
- Make sure both relations share the same attributes. **Otherwise**, print error message "*relation_one and relation_two does not have same schema!*" and return *None*.
- Intersect operator function should return **distinct** records.
- **DO NOT** use pandas methods to construct operator function. You can use:
  - python's list/dictionary manipulation
  - the utility functions provided above
  - other relational operators implemented in this notebook
- Columns in result/output can be displayed in any order.
"""

def intersect (relation_one: Table, relation_two: Table) -> Table:
    """
    Performs intersect on two relations
        :param relation_one: Table object, one relation for intersect
        :param relation_two: Table object, the other relation for intersect
        :return: Table Object, the intersection of the two relations

    """
    intersected_relation = Table("Intersect_Relation")

    # Enter your code below
    return intersected_relation

relation_intersect = select (bars, "( name = 'SoberBar' )")
R = intersect(bars, relation_intersect)
view_table(R)

"""## 3.6 CARTESIAN PRODUCT Operator -- *Provided to You*

### **Actions**
- Run the code below to define the CARTESIAN PRODUCT operator.

**cartesian (relation_one, relation_two)**
- Performs Cartesian operation on two relations
- Parameters:
  - relation_one: Table Object, the R1 relation in the cartesian product
  - relation_two: Table Object, the R2 relation in the cartesian product
- Returns:
  - Table Object, the resulted relation after R1 $\times$ R2
- **IMPORTANT** Doing this operation adds "_x" to left relation's attribute names and "_y" to right relation's attribute names.
"""

def cartesian (relation_one: Table, relation_two: Table) -> Table:
    """
    Performs Cartesian operation on two relations
        :param relation_one: Table object, the R1 relation in the cartesian product
        :param relation_two: Table object, the R2 relation in the cartesian product
        :return: Table object, the resulted relation after R1 × R2
    """
    relation_one_records = relation_one.getTuples()
    relation_two_records = relation_two.getTuples()
    records: list = []
    for rec1 in relation_one_records:
        for rec2 in relation_two_records:
            new_record: dict = {str(key1) + "_x" : rec1[key1] for key1 in rec1}
            new_record.update({str(key2) + "_y" : rec2[key2] for key2 in rec2})
            records.append(new_record)

    cartesian_table = Table("CartesianTable")
    cartesian_table.data = records
    return cartesian_table

R = cartesian(bars, drinkers)
view_table(R)

"""## 3.7 JOIN Operator -- *You Provide It* **(Submission 3)**

### **Actions**
- Implement the JOIN operator.

**join (relation_one, relation_two, condition)**
- Performs Theta JOIN on two relations
- Parameters:
  - relation_one: Table Object, the R1 relation in the theta join
  - relation_two: Table Object, the R2 relation in the theta join
  - condition: str, the condition for theta join
- Returns:
  - Table Object, the resulted relation after R1 $\bowtie_\theta$ R2
- **IMPORTANT** Join uses caresian function. Cartesian adds "_x" and "_y" to relation attribute names. Specify the colum name accordingly in join condition.
- Attributes mentioned in the join condition must exist in either relation. **Otherwise**, print error message "*Condition Syntax Error*" and return *None*.
- **DO NOT** use pandas methods to construct operator function. You can use:
  - python's list/dictionary manipulation
  - the utility functions provided above
  - other relational operators implemented in this notebook
- Columns in result/output can be displayed in any order.
- We don't have any requirement on the Table name.
- You don't need to remove the duplicates.
"""

def join (relation_one: Table, relation_two: Table, join_condition: str) -> Table:
    """
    Performs Theta JOIN on two relations
        :param relation_one: Table object, the R1 relation in the theta join
        :param relation_two: Table object, the R2 relation in the theta join
        :param condition: str, the condition for theta join
        :return: Table object, the resulted relation after R1 theta join R2
        Hint: Use cartesian function provided
    """

    join_relation = Table("JoinTable")

    # Enter your code below

    return join_relation

R = join(beers, sells, "( beer_x = beer_y ) AND ( price_y > 3.0 ) AND ( bar_y = 'SoberBar' )")
view_table(R)

"""## 3.8 RENAME Operator -- *Provided to You*

### **Actions**
- Run the code below to define the RENAME operator.

**rename (relation, attr_name, new_attr_name)**
- Performs Rename on the given relation
- Parameters:
  - relation: Table Object, the relation to be manipulated
  - attr_name: str, the original attribute name
  - new_attr_name: str, the new attribute name
- Returns:
  - Table Object, the relation after the attribute is renamed.
"""

import copy

def rename (relation: Table, attr_name: str, new_attr_name: str ) -> Table:
      """
      Rename Operator
        :param relation: Table Object, the relation to be manipulated
        :param attr_name: str, the original attribute name
        :param new_attr_name: str, the new attribute name
        :return: Table Object, the relation after the attribute is renamed
      """
      renamed_table = Table("RenamedTable")
      records = relation.getTuples()
      new_records = copy.deepcopy(records)

      for record in new_records:
          if attr_name in record:
            record[new_attr_name] = record[attr_name]
            del record[attr_name]
          else:
              print("Attribute not present")
              return None

      renamed_table.data = new_records

      return renamed_table

view_table(rename(bars, "addr","new_addr"))

"""# 4. Queries: Relational Expressions

### **Actions**
- Run Query 1 to see how to view a table or the result of a query.
- Run Query 2 to see how our operators work together to answer a query.
- Write your code solutions for Query 3 and Query 4. **You will write two variants to answer each query**-- to experience how different relational algebra expressions can be equivalent. Here, two variants are considered **_different_** if they use different operators or have different orders of operations.

## 4.1 **Query 1.** Show a table or query results -- *Provided to You*
"""

# Show the beers table
view_table(beers)

# Show the drinkers table
view_table(drinkers)

# Show the bars table
view_table(bars)

# Show the sells table
view_table(sells)

# Show the result of a query
view_table (
    select ( sells, "( price >= 5.0 )")
)

"""## 4.2 **Query 2.** Beers made by "ABInBev" or with alcohol 0.05 or higher  -- *Provided to You*"""

# Variant A: The first query variant for answering this query.
view_table (
        union(
        select(beers, "( brewer = 'ABInBev' )"),
        select(beers, "( alcohol >= 0.05 )")
        )
)

# Variant B: The second query variant for answering this query.
view_table (
        select(beers, "( brewer = 'ABInBev' ) OR ( alcohol >= 0.05 )")
)

"""## 4.3 **Query 3.** Beers with price lower than 5.0 and alcohol higher than 0.045 -- *You Provide It* **(Submission 4)**

### **Actions**
- Schema (i.e. columns) to be returned - (beer).
- Columns in result/output can be displayed in any order.
- Filter out NaN values by using > 0 condition for beer price.
- Hints: you could use either join or intersect (using different operators for two variants).
"""

# Variant A: The first query variant for answering this query.

# Write your query here.

# Variant B: The second query variant for answering this query.

# Write your query here.

"""## 4.4 **Query 4.** For each Bar - Find the most expensive beer (highest price) or beers (If more than one beer is of the highest price) -- *You Provide It* **(Submission 5)**

### **Actions**
- Schema (i.e. columns) to be returned - (bar, beer, price).
- Please use the relation operator functions to get the results. **DO NOT use pythons aggregate functions** to achieve the desired output.
- Do not use Python in-built dictionary/list or loops. Only previous relational operator functions are allowed.
- Use Select function with price >= 0 for removing NaN values
- Columns in result/output can be displayed in any order.
- Please use **different set of operators** for two variants.
- Your solution should be general and be applicable to similar data with different bar names, beer names, and prices. You should not mention specific bar names or prices.
"""

# Variant A: The first query variant for answering this query.

# Write your query here.

# Variant B: The second query variant for answering this query.

# Write your query here.